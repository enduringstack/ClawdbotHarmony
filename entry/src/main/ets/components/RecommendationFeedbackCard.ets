/**
 * RecommendationFeedbackCard â€” æ¨èå¡ç‰‡ + åé¦ˆæŒ‰é’®
 *
 * æ˜¾ç¤ºæƒ…æ™¯å¼•æ“æ¨èå†…å®¹ï¼Œåº•éƒ¨å³ä¾§æœ‰ ğŸ‘/ğŸ‘ æŒ‰é’®ã€‚
 * ç‚¹å‡»æŒ‰é’®åæŒ‰é’®éšè—å¹¶æ˜¾ç¤º "æ„Ÿè°¢åé¦ˆ" toastã€‚
 * ç‚¹å‡»å¡ç‰‡ä¸»åŒºåŸŸè§¦å‘ onActionTapï¼ˆéšå¼æ­£åé¦ˆ +0.8ï¼‰ã€‚
 * æ”¯æŒæ»‘åŠ¨å…³é—­ï¼ˆdismiss åé¦ˆ -0.1 å»¶è¿Ÿ 5minï¼‰ã€‚
 */

@Component
export struct RecommendationFeedbackCard {
  /** è§„åˆ™ ID */
  @Prop ruleId: string = '';
  /** æ¨èæ–‡æœ¬ / åŸå›  */
  @Prop reason: string = '';
  /** åŠ¨ä½œç±»å‹æ ‡ç­¾ */
  @Prop actionLabel: string = '';
  /** ç½®ä¿¡åº¦ 0-1 */
  @Prop confidence: number = 0;

  /** å›è°ƒ */
  onThumbsUp: (ruleId: string) => void = () => {};
  onThumbsDown: (ruleId: string) => void = () => {};
  onActionTap: (ruleId: string) => void = () => {};
  onDismiss: (ruleId: string) => void = () => {};

  /** å†…éƒ¨çŠ¶æ€ */
  @State feedbackGiven: boolean = false;
  @State toastText: string = '';
  @State showToast: boolean = false;
  @State offsetX: number = 0;

  build() {
    Column() {
      // ä¸»å¡ç‰‡
      Stack({ alignContent: Alignment.BottomEnd }) {
        // å¡ç‰‡å†…å®¹åŒº â€” å¯ç‚¹å‡»æ‰§è¡Œæ¨èåŠ¨ä½œ
        Column() {
          // é¡¶éƒ¨ï¼šåŠ¨ä½œç±»å‹æ ‡ç­¾ + ç½®ä¿¡åº¦
          Row() {
            Text(this.actionIcon())
              .fontSize(14)
            Text(this.actionLabel.length > 0 ? this.actionLabel : this.defaultActionLabel())
              .fontSize(12)
              .fontColor('#007AFF')
              .fontWeight(FontWeight.Medium)
              .margin({ left: 4 })
            Blank()
            if (this.confidence > 0) {
              Text(Math.round(this.confidence * 100).toString() + '%')
                .fontSize(11)
                .fontColor('#999999')
            }
          }
          .width('100%')

          // æ¨èå†…å®¹
          Text(this.reason)
            .fontSize(15)
            .fontColor('#1A1A1A')
            .lineHeight(22)
            .width('100%')
            .margin({ top: 8 })

          // åº•éƒ¨ï¼šæç¤º + åé¦ˆæŒ‰é’®
          Row() {
            Text('è½»è§¦æ‰§è¡Œ')
              .fontSize(11)
              .fontColor('#CCCCCC')
              .layoutWeight(1)

            if (!this.feedbackGiven) {
              // ğŸ‘ æŒ‰é’®
              Text('\uD83D\uDC4D')
                .fontSize(20)
                .width(36)
                .height(36)
                .textAlign(TextAlign.Center)
                .borderRadius(18)
                .backgroundColor('#F0F8F0')
                .onClick(() => {
                  this.handleThumbsUp();
                })

              // ğŸ‘ æŒ‰é’®
              Text('\uD83D\uDC4E')
                .fontSize(20)
                .width(36)
                .height(36)
                .textAlign(TextAlign.Center)
                .borderRadius(18)
                .backgroundColor('#FFF0F0')
                .margin({ left: 8 })
                .onClick(() => {
                  this.handleThumbsDown();
                })
            }
          }
          .width('100%')
          .margin({ top: 12 })
          .alignItems(VerticalAlign.Center)
        }
        .width('100%')
        .padding(16)
        .onClick(() => {
          this.handleActionTap();
        })

        // æ„Ÿè°¢åé¦ˆ toast
        if (this.showToast) {
          Text(this.toastText)
            .fontSize(12)
            .fontColor(Color.White)
            .backgroundColor('#4CAF50')
            .borderRadius(12)
            .padding({ left: 12, right: 12, top: 6, bottom: 6 })
            .margin({ bottom: 50, right: 8 })
        }
      }
      .width('100%')
      .backgroundColor(Color.White)
      .borderRadius(12)
      .shadow({ radius: 4, color: '#0000000D', offsetX: 0, offsetY: 2 })
    }
    .width('100%')
    .offset({ x: this.offsetX })
    .gesture(
      PanGesture({ direction: PanDirection.Horizontal })
        .onActionUpdate((event: GestureEvent) => {
          this.offsetX = event.offsetX;
        })
        .onActionEnd((event: GestureEvent) => {
          if (Math.abs(event.offsetX) > 120) {
            // æ»‘èµ° â†’ dismiss
            this.offsetX = event.offsetX > 0 ? 400 : -400;
            this.onDismiss(this.ruleId);
          } else {
            this.offsetX = 0;
          }
        })
    )
    .animation({ duration: 200, curve: Curve.EaseOut })
  }

  private handleThumbsUp(): void {
    this.feedbackGiven = true;
    this.toastText = 'æ„Ÿè°¢åé¦ˆ';
    this.showToast = true;
    this.onThumbsUp(this.ruleId);
    this.hideToastLater();
  }

  private handleThumbsDown(): void {
    this.feedbackGiven = true;
    this.toastText = 'æ„Ÿè°¢åé¦ˆ';
    this.showToast = true;
    this.onThumbsDown(this.ruleId);
    this.hideToastLater();
  }

  private handleActionTap(): void {
    if (this.feedbackGiven) return;
    this.feedbackGiven = true;
    this.toastText = 'å·²æ‰§è¡Œ';
    this.showToast = true;
    this.onActionTap(this.ruleId);
    this.hideToastLater();
  }

  private hideToastLater(): void {
    setTimeout(() => {
      this.showToast = false;
    }, 1500);
  }

  private actionIcon(): string {
    let label = this.actionLabel;
    if (label === 'suggestion') return '\uD83D\uDCA1';
    if (label === 'notification') return '\uD83D\uDD14';
    if (label === 'automation') return '\u2699\uFE0F';
    return '\uD83D\uDCA1';
  }

  private defaultActionLabel(): string {
    let label = this.actionLabel;
    if (label === 'suggestion') return 'æ™ºèƒ½å»ºè®®';
    if (label === 'notification') return 'æé†’';
    if (label === 'automation') return 'è‡ªåŠ¨åŒ–';
    return 'æ¨è';
  }
}
