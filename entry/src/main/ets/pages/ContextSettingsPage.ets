/**
 * ContextSettingsPage â€” æƒ…æ™¯æ™ºèƒ½ç®¡ç†é¡µé¢
 * åŠŸèƒ½ï¼šåœ°ç†å›´æ ç®¡ç† / è§„åˆ™å¼•æ“çŠ¶æ€ / MAB ç»Ÿè®¡
 */
import { router, promptAction } from '@kit.ArkUI';
import { LogService } from '../common/LogService';
import { I18n } from '../common/I18n';
import { ContextAwarenessService } from '../service/context/ContextAwarenessService';
import { ContextEngineService } from '../service/context/ContextEngine';
import { FeedbackService } from '../service/context/FeedbackService';
import { Geofence, GeofenceCategory, FeedbackStats, FeedbackRuleStat } from '../service/context/ContextModels';
import { LocationDiscoveryService, GeofenceSuggestion } from '../service/context/LocationDiscoveryService';
import { LearnedSignalsSummary } from '../service/context/LocationFusionService';
import { GeofenceSuggestionCard } from '../components/GeofenceSuggestionCard';
import { TrayStatus } from '../service/context/DataTray';

@Entry
@Component
struct ContextSettingsPage {
  private log: LogService = LogService.getInstance();

  @State geofenceNames: string[] = [];
  @State geofenceDetails: string[] = [];
  @State geofenceIds: string[] = [];
  @State ruleCount: number = 0;
  @State mabStats: string = '';
  @State engineStatus: string = '';
  @State suggestions: GeofenceSuggestion[] = [];
  @State discoveryStats: string = '';
  @State showAddDialog: boolean = false;
  @State newName: string = '';
  @State newLat: string = '';
  @State newLon: string = '';
  @State newRadius: string = '100';
  @State selectedCat: number = 6;

  // åé¦ˆç»Ÿè®¡
  @State fbTotal: number = 0;
  @State fbPositive: number = 0;
  @State fbNegative: number = 0;
  @State fbRatioText: string = '--';
  @State fbTopRuleNames: string[] = [];
  @State fbTopRuleScores: string[] = [];

  // ç§¯ææ¢ç´¢æ¨¡å¼
  @State exploreMode: boolean = false;
  @State exploreFpCount: number = 0;
  // å·²å­¦ä¹ çš„ä½ç½®ä¿¡å·
  @State learnedSignals: LearnedSignalsSummary[] = [];
  // æ•°æ®æ‰˜ç›˜ â€” ç‰©ç†ä¸–ç•Œ
  @State physKeys: string[] = [];
  @State physLabels: string[] = [];
  @State physValues: string[] = [];
  @State physAges: string[] = [];
  @State physIndicators: string[] = [];
  @State physQualities: string[] = [];
  // æ•°æ®æ‰˜ç›˜ â€” æ•°å­—ä¸–ç•Œ
  @State digiKeys: string[] = [];
  @State digiLabels: string[] = [];
  @State digiValues: string[] = [];
  @State digiAges: string[] = [];
  @State digiIndicators: string[] = [];
  @State digiQualities: string[] = [];
  private trayTimer: number = -1;
  // å½“å‰çŠ¶æ€æ¦‚è§ˆ
  @State statusTime: string = '';
  @State statusLocation: string = '';
  @State statusMotion: string = '';
  @State statusBattery: string = '';
  @State statusWifi: string = '';

  // key â†’ ä¸­æ–‡æ ‡ç­¾æ˜ å°„
  private static readonly KEY_LABELS: Record<string, string> = {
    // ---- ç‰©ç†ä¸–ç•Œï¼ˆä¼ æ„Ÿå™¨ + ç¯å¢ƒï¼‰ ----
    'hour': 'å°æ—¶',
    'timeOfDay': 'æ—¶æ®µ',
    'dayOfWeek': 'æ˜ŸæœŸ',
    'isWeekend': 'å‘¨æœ«',
    'batteryLevel': 'ç”µé‡',
    'isCharging': 'å……ç”µä¸­',
    'networkType': 'ç½‘ç»œç±»å‹',
    'wifiSsid': 'WiFiåç§°',
    'wifiLost': 'WiFiä¸¢å¤±',
    'wifiLostCategory': 'WiFiä¸¢å¤±åˆ†ç±»',
    'wifiLostWork': 'ç¦»å¼€å…¬å¸WiFi',
    'latitude': 'çº¬åº¦',
    'longitude': 'ç»åº¦',
    'geofence': 'å›´æ ',
    'stepCount': 'æ­¥æ•°(ç´¯è®¡)',
    'step_count_today': 'ä»Šæ—¥æ­¥æ•°',
    'motionState': 'è¿åŠ¨çŠ¶æ€',
    'isPickup': 'æ‹¿èµ·æ‰‹æœº',
    'gpsSpeed': 'GPSé€Ÿåº¦',
    'locationAccuracy': 'å®šä½ç²¾åº¦(m)',
    'cellId': 'åŸºç«™ID',
    // è“ç‰™
    'bt_enabled': 'è“ç‰™å¼€å¯',
    'bt_connected_count': 'è“ç‰™è¿æ¥æ•°',
    'bt_audio_connected': 'è“ç‰™éŸ³é¢‘',
    'bt_device_names': 'è“ç‰™è®¾å¤‡',
    // ç©¿æˆ´è®¾å¤‡
    'heart_rate': 'å¿ƒç‡',
    'heart_rate_status': 'å¿ƒç‡çŠ¶æ€',
    'heart_rate_age_sec': 'å¿ƒç‡æ•°æ®é¾„(ç§’)',
    'wearing_state': 'ä½©æˆ´çŠ¶æ€',
    // éŸ³é¢‘ç¯å¢ƒ
    'audio_scene': 'éŸ³é¢‘åœºæ™¯',
    'audio_device': 'éŸ³é¢‘è®¾å¤‡',
    'audio_inCall': 'é€šè¯ä¸­',
    'audio_ringing': 'å“é“ƒä¸­',
    'audio_headphones': 'è€³æœºè¿æ¥',
    'noise_level': 'å™ªéŸ³ç­‰çº§',
    'sound_scene': 'å£°éŸ³åœºæ™¯',
    'has_voice': 'æ£€æµ‹åˆ°äººå£°',
    'volume_db': 'éŸ³é‡(dB)',
    // å§¿æ€
    'phone_posture': 'æ‰‹æœºå§¿æ€',
    'ambient_brightness': 'ç¯å¢ƒäº®åº¦(lux)',
    'proximity': 'è¿‘è·ç¦»æ„Ÿåº”',
    // ---- æ•°å­—ä¸–ç•Œï¼ˆåº”ç”¨ / ä¿¡æ¯ï¼‰ ----
    // æ—¥å†
    'cal_eventCount': 'æ—¥å†äº‹ä»¶æ•°',
    'cal_hasUpcoming': 'æœ‰å¾…åŠäº‹ä»¶',
    'cal_nextTitle': 'ä¸‹ä¸ªæ—¥ç¨‹',
    'cal_nextMinutes': 'ä¸‹ä¸ªæ—¥ç¨‹(åˆ†é’Ÿ)',
    'cal_nextLocation': 'æ—¥ç¨‹åœ°ç‚¹',
    'cal_inMeeting': 'ä¼šè®®ä¸­',
    'cal_currentTitle': 'å½“å‰ä¼šè®®',
    'cal_todayCount': 'ä»Šæ—¥æ—¥ç¨‹æ•°',
    // åº”ç”¨ä½¿ç”¨
    'app_isForeground': 'åº”ç”¨åœ¨å‰å°',
    'app_sessionMinutes': 'æœ¬æ¬¡ä½¿ç”¨(åˆ†é’Ÿ)',
    'app_sessionsToday': 'ä»Šæ—¥ä½¿ç”¨æ¬¡æ•°',
    'app_canReadOthers': 'å¯è¯»å–å…¶ä»–åº”ç”¨',
    // å‰å°åº”ç”¨
    'foreground_app': 'å‰å°åº”ç”¨',
    'app_category': 'åº”ç”¨ç±»åˆ«',
    'app_usage_min': 'åº”ç”¨ä½¿ç”¨(åˆ†é’Ÿ)',
    // é€šçŸ¥
    'notif_enabled': 'é€šçŸ¥å·²å¼€å¯',
    'notif_selfCount': 'æœ¬åº”ç”¨é€šçŸ¥æ•°',
    'notif_canReadOthers': 'å¯è¯»å–å…¶ä»–é€šçŸ¥',
    'notif_lastSentMinutes': 'ä¸Šæ¬¡é€šçŸ¥(åˆ†é’Ÿ)',
  };

  private catIds: string[] = ['home', 'work', 'transit', 'shopping', 'restaurant', 'gym', 'custom'];
  @State catLabels: string[] = ['ğŸ  å®¶', 'ğŸ¢ å…¬å¸', 'ğŸš‡ äº¤é€š', 'ğŸ›’ è´­ç‰©', 'ğŸœ é¤é¥®', 'ğŸ’ª å¥èº«', 'ğŸ“ è‡ªå®šä¹‰'];

  aboutToAppear(): void {
    this.log.info('CtxSettings', 'Page opened');
    // ç”¨ I18n åˆå§‹åŒ–åˆ†ç±»æ ‡ç­¾
    let labels: string[] = [];
    for (let i = 0; i < this.catIds.length; i++) {
      labels.push(this.getCatIcon(this.catIds[i]) + ' ' + I18n.t('place.category.' + this.catIds[i]));
    }
    this.catLabels = labels;
    this.refresh();
    this.refreshTrayStatus();
    // Auto-refresh tray every 5 seconds
    this.trayTimer = setInterval(() => {
      this.refreshTrayStatus();
    }, 5000);
  }

  aboutToDisappear(): void {
    if (this.trayTimer !== -1) {
      clearInterval(this.trayTimer);
      this.trayTimer = -1;
    }
  }

  private getCatLabel(cat: string): string {
    let icon = this.getCatIcon(cat);
    let label = I18n.t('place.category.' + cat);
    return icon + ' ' + label;
  }

  private getCatIcon(cat: string): string {
    if (cat === 'home') return 'ğŸ ';
    if (cat === 'work') return 'ğŸ¢';
    if (cat === 'transit') return 'ğŸš‡';
    if (cat === 'gym') return 'ğŸ’ª';
    if (cat === 'restaurant') return 'ğŸœ';
    if (cat === 'shopping') return 'ğŸ›’';
    return 'ğŸ“';
  }

  private refresh(): void {
    try {
      let cas = ContextAwarenessService.getInstance();
      let gfs = cas.getAllGeofences();
      let names: string[] = [];
      let details: string[] = [];
      let ids: string[] = [];
      for (let i = 0; i < gfs.length; i++) {
        let gf = gfs[i];
        names.push(this.getCatLabel(gf.category) + ' ' + gf.name);
        details.push(gf.latitude.toFixed(4) + ', ' + gf.longitude.toFixed(4) + '  r=' + gf.radiusMeters.toString() + 'm');
        ids.push(gf.id);
      }
      this.geofenceNames = names;
      this.geofenceDetails = details;
      this.geofenceIds = ids;
      this.engineStatus = cas.getStatus();
      this.exploreMode = cas.isExploreMode();
      this.learnedSignals = cas.getLearnedSignalsSummaries();
      this.suggestions = cas.getLocationSuggestions();
      this.suggestions = cas.getFilteredSuggestions();
      let stats = cas.getLocationDiscoveryStats();
      this.discoveryStats = `å†å²ç‚¹: ${stats.historyCount} | èšç±»: ${stats.clusterCount} | ä¸Šæ¬¡å‘ç°: ${stats.lastDiscovery}`;
    } catch (err) {
      this.log.warn('CtxSettings', 'refresh cas: ' + (err as Error).message);
      this.engineStatus = 'æƒ…æ™¯æ™ºèƒ½æœªåˆå§‹åŒ–';
      this.discoveryStats = '';
      this.suggestions = [];
    }
    try {
      this.ruleCount = ContextEngineService.getInstance().getRuleCount();
    } catch (err) {
      this.ruleCount = 0;
    }
    this.refreshFeedbackStats();
  }

  private refreshFeedbackStats(): void {
    try {
      // Use FeedbackService directly to get latest stats (including A2UI button feedback)
      let stats: FeedbackStats = FeedbackService.getInstance().getStats();
      this.fbTotal = stats.totalCount;
      this.fbPositive = stats.positiveCount;
      this.fbNegative = stats.negativeCount;
      if (stats.positiveCount + stats.negativeCount > 0) {
        this.fbRatioText = Math.round(stats.positiveRatio * 100).toString() + '%';
      } else {
        this.fbRatioText = '--';
      }
      let names: string[] = [];
      let scores: string[] = [];
      for (let i = 0; i < stats.topRules.length; i++) {
        let tr: FeedbackRuleStat = stats.topRules[i];
        names.push(tr.ruleName);
        scores.push(tr.avgReward.toFixed(2) + ' (' + tr.feedbackCount.toString() + ' fb)');
      }
      this.fbTopRuleNames = names;
      this.fbTopRuleScores = scores;
    } catch (err) {
      this.fbTotal = 0;
      this.fbRatioText = '--';
    }
  }

  build() {
    Stack() {
      Column() {
        // Header
        Row() {
          Text('â†')
            .fontSize(22)
            .fontColor('#1A1A1A')
            .padding(8)
            .onClick(() => { router.back(); })
          Text('æƒ…æ™¯æ™ºèƒ½è®¾ç½®')
            .fontSize(18)
            .fontWeight(FontWeight.Bold)
            .fontColor('#1A1A1A')
            .layoutWeight(1)
        }
        .width('100%')
        .height(48)
        .padding({ left: 8, right: 16 })
        .backgroundColor(Color.White)

        Scroll() {
          Column({ space: 16 }) {
            // ===== å½“å‰çŠ¶æ€æ¦‚è§ˆ =====
            Column({ space: 6 }) {
              Text('å½“å‰çŠ¶æ€')
                .fontSize(16)
                .fontWeight(FontWeight.Bold)
                .fontColor(Color.White)
                .margin({ bottom: 4 })
              Row({ space: 12 }) {
                Text(this.statusTime)
                  .fontSize(13)
                  .fontColor('#E0E0E0')
                Text(this.statusMotion)
                  .fontSize(13)
                  .fontColor('#E0E0E0')
                Text(this.statusBattery)
                  .fontSize(13)
                  .fontColor('#E0E0E0')
              }
              .width('100%')
              if (this.statusLocation.length > 0) {
                Text(this.statusLocation)
                  .fontSize(13)
                  .fontColor('#E0E0E0')
                  .width('100%')
                  .margin({ top: 2 })
              }
              if (this.statusWifi.length > 0) {
                Text(this.statusWifi)
                  .fontSize(13)
                  .fontColor('#E0E0E0')
                  .width('100%')
              }
            }
            .width('100%')
            .padding(16)
            .linearGradient({
              direction: GradientDirection.Right,
              colors: [['#2196F3', 0.0], ['#1976D2', 1.0]]
            })
            .borderRadius(12)

            // ===== å¼•æ“çŠ¶æ€ =====
            Column() {
              Text('å¼•æ“çŠ¶æ€')
                .fontSize(16)
                .fontWeight(FontWeight.Bold)
                .fontColor('#1A1A1A')
                .margin({ bottom: 8 })
              Text(this.engineStatus)
                .fontSize(13)
                .fontColor('#666666')
                .width('100%')
              Text('C++ è§„åˆ™æ•°: ' + this.ruleCount.toString())
                .fontSize(13)
                .fontColor('#666666')
                .margin({ top: 4 })
              Text('ç®¡ç†è§„åˆ™ \u2192')
                .fontSize(14)
                .fontColor('#007AFF')
                .margin({ top: 10 })
                .onClick(() => {
                  router.pushUrl({ url: 'pages/RuleManagementPage' });
                })
            }
            .width('100%')
            .padding(16)
            .backgroundColor(Color.White)
            .borderRadius(12)

            // ===== ç§¯ææ¢ç´¢æ¨¡å¼ =====
            Column() {
              Row() {
                Column() {
                  Text(I18n.t('context.explore.title'))
                    .fontSize(15)
                    .fontWeight(FontWeight.Medium)
                    .fontColor('#1A1A1A')
                  Text(I18n.t('context.explore.desc'))
                    .fontSize(12)
                    .fontColor('#999999')
                    .margin({ top: 2 })
                }
                .layoutWeight(1)
                .alignItems(HorizontalAlign.Start)

                Toggle({ type: ToggleType.Switch, isOn: this.exploreMode })
                  .selectedColor('#007AFF')
                  .onChange((isOn: boolean) => {
                    this.exploreMode = isOn;
                    ContextAwarenessService.getInstance().setExploreMode(isOn);
                  })
              }
              .width('100%')
            }
            .width('100%')
            .padding(16)
            .backgroundColor(Color.White)
            .borderRadius(12)

            // ===== æ•°æ®æ‰˜ç›˜ =====
            Column() {
              Row() {
                Text('\u{1F4E1} æ•°æ®æ‰˜ç›˜ (' + (this.physKeys.length + this.digiKeys.length).toString() + ')')
                  .fontSize(16)
                  .fontWeight(FontWeight.Bold)
                  .fontColor('#1A1A1A')
                  .layoutWeight(1)
                Text('åˆ·æ–°')
                  .fontSize(14)
                  .fontColor('#007AFF')
                  .onClick(() => { this.refreshTrayStatus(); })
              }
              .width('100%')
              .margin({ bottom: 4 })

              Text('æ¯ 5 ç§’è‡ªåŠ¨åˆ·æ–°')
                .fontSize(11)
                .fontColor('#BBBBBB')
                .width('100%')
                .margin({ bottom: 8 })

              if (this.physKeys.length === 0 && this.digiKeys.length === 0) {
                Text('æ‰˜ç›˜ä¸ºç©ºï¼ˆä¼ æ„Ÿå™¨æœªå¼€å§‹å†™å…¥ï¼‰')
                  .fontSize(13)
                  .fontColor('#999999')
                  .width('100%')
                  .textAlign(TextAlign.Center)
                  .padding(16)
              } else {
                // â”€â”€ ç‰©ç†ä¸–ç•Œ â”€â”€
                Text('\u{1F30D} ç‰©ç†ä¸–ç•Œ (' + this.physKeys.length.toString() + ')')
                  .fontSize(13)
                  .fontWeight(FontWeight.Bold)
                  .fontColor('#2E7D32')
                  .width('100%')
                  .margin({ bottom: 4, top: 4 })

                Row() {
                  Text('åç§°').fontSize(11).fontColor('#999999').fontWeight(FontWeight.Medium).width(90)
                  Text('æ•°å€¼').fontSize(11).fontColor('#999999').fontWeight(FontWeight.Medium).layoutWeight(1)
                  Text('é¾„').fontSize(11).fontColor('#999999').fontWeight(FontWeight.Medium).width(40)
                  Text('è´¨').fontSize(11).fontColor('#999999').fontWeight(FontWeight.Medium).width(32)
                  Text('').width(18)
                }.width('100%').padding({ bottom: 2 })

                ForEach(this.physKeys, (key: string, idx: number) => {
                  Row() {
                    Text(idx < this.physLabels.length ? this.physLabels[idx] : key)
                      .fontSize(12).fontColor('#1A1A1A').width(90).maxLines(1)
                      .textOverflow({ overflow: TextOverflow.Ellipsis })
                    Text(idx < this.physValues.length ? this.physValues[idx] : '')
                      .fontSize(12).fontColor('#666666').layoutWeight(1).maxLines(1)
                      .textOverflow({ overflow: TextOverflow.Ellipsis })
                    Text(idx < this.physAges.length ? this.physAges[idx] : '')
                      .fontSize(11).fontColor('#999999').width(40)
                    Text(idx < this.physQualities.length ? this.physQualities[idx] : '')
                      .fontSize(11).fontColor('#999999').width(32)
                    Text(idx < this.physIndicators.length ? this.physIndicators[idx] : '')
                      .fontSize(12).width(18)
                  }.width('100%').padding({ top: 2, bottom: 2 })
                }, (key: string, idx: number) => 'p_' + key + '_' + idx.toString())

                // â”€â”€ æ•°å­—ä¸–ç•Œ â”€â”€
                Text('\u{1F4F1} æ•°å­—ä¸–ç•Œ (' + this.digiKeys.length.toString() + ')')
                  .fontSize(13)
                  .fontWeight(FontWeight.Bold)
                  .fontColor('#1565C0')
                  .width('100%')
                  .margin({ bottom: 4, top: 12 })

                if (this.digiKeys.length === 0) {
                  Text('æš‚æ— æ’ä»¶æ•°æ®')
                    .fontSize(12).fontColor('#999999').width('100%')
                    .textAlign(TextAlign.Center).padding(8)
                } else {
                  Row() {
                    Text('åç§°').fontSize(11).fontColor('#999999').fontWeight(FontWeight.Medium).width(90)
                    Text('æ•°å€¼').fontSize(11).fontColor('#999999').fontWeight(FontWeight.Medium).layoutWeight(1)
                    Text('é¾„').fontSize(11).fontColor('#999999').fontWeight(FontWeight.Medium).width(40)
                    Text('è´¨').fontSize(11).fontColor('#999999').fontWeight(FontWeight.Medium).width(32)
                    Text('').width(18)
                  }.width('100%').padding({ bottom: 2 })

                  ForEach(this.digiKeys, (key: string, idx: number) => {
                    Row() {
                      Text(idx < this.digiLabels.length ? this.digiLabels[idx] : key)
                        .fontSize(12).fontColor('#1A1A1A').width(90).maxLines(1)
                        .textOverflow({ overflow: TextOverflow.Ellipsis })
                      Text(idx < this.digiValues.length ? this.digiValues[idx] : '')
                        .fontSize(12).fontColor('#666666').layoutWeight(1).maxLines(1)
                        .textOverflow({ overflow: TextOverflow.Ellipsis })
                      Text(idx < this.digiAges.length ? this.digiAges[idx] : '')
                        .fontSize(11).fontColor('#999999').width(40)
                      Text(idx < this.digiQualities.length ? this.digiQualities[idx] : '')
                        .fontSize(11).fontColor('#999999').width(32)
                      Text(idx < this.digiIndicators.length ? this.digiIndicators[idx] : '')
                        .fontSize(12).width(18)
                    }.width('100%').padding({ top: 2, bottom: 2 })
                  }, (key: string, idx: number) => 'd_' + key + '_' + idx.toString())
                }
              }
            }
            .width('100%')
            .padding(16)
            .backgroundColor(Color.White)
            .borderRadius(12)

            // ===== åœ°ç†å›´æ  =====
            Column() {
              Row() {
                Text('åœ°ç†å›´æ  (' + this.geofenceNames.length.toString() + ')')
                  .fontSize(16)
                  .fontWeight(FontWeight.Bold)
                  .fontColor('#1A1A1A')
                  .layoutWeight(1)
                Text('ï¼‹ æ·»åŠ ')
                  .fontSize(14)
                  .fontColor('#007AFF')
                  .onClick(() => { this.showAddDialog = true; })
              }
              .width('100%')
              .margin({ bottom: 12 })

              if (this.geofenceNames.length === 0) {
                Text('æš‚æ— å›´æ ï¼Œç‚¹å‡»å³ä¸Šè§’æ·»åŠ ')
                  .fontSize(14)
                  .fontColor('#999999')
                  .width('100%')
                  .textAlign(TextAlign.Center)
                  .padding(20)
              } else {
                ForEach(this.geofenceIds, (gfId: string, index: number) => {
                  Column() {
                    Row() {
                      Column({ space: 2 }) {
                        Text(this.geofenceNames[index])
                          .fontSize(14)
                          .fontColor('#1A1A1A')
                        Text(this.geofenceDetails[index])
                          .fontSize(11)
                          .fontColor('#999999')
                      }
                      .layoutWeight(1)
                      .alignItems(HorizontalAlign.Start)

                      Text('åˆ é™¤')
                        .fontSize(13)
                        .fontColor('#FF3B30')
                        .padding(4)
                        .onClick(() => { this.deleteGeofence(gfId); })
                    }
                    .width('100%')
                    .padding({ top: 8, bottom: 8 })
                    Divider().color('#F0F0F0')
                  }
                }, (gfId: string) => gfId)
              }
            }
            .width('100%')
            .padding(16)
            .backgroundColor(Color.White)
            .borderRadius(12)

            // ===== å·²å­¦ä¹ çš„ä½ç½®ä¿¡å· =====
            Column() {
              Row() {
                Text('ä½ç½®ä¿¡å·å­¦ä¹ ')
                  .fontSize(16)
                  .fontWeight(FontWeight.Bold)
                  .fontColor('#1A1A1A')
                  .layoutWeight(1)
                Text('æ¸…é™¤å…¨éƒ¨')
                  .fontSize(13)
                  .fontColor('#FF3B30')
                  .onClick(() => { this.clearAllSignals(); })
              }
              .width('100%')
              .margin({ bottom: 8 })

              Text('GPS é«˜ç²¾åº¦æ—¶è‡ªåŠ¨å­¦ä¹  WiFi/è“ç‰™ä¿¡å·ï¼Œç”¨äºå®¤å†…å®šä½å¢å¼º')
                .fontSize(12)
                .fontColor('#999999')
                .width('100%')
                .margin({ bottom: 8 })

              if (this.learnedSignals.length === 0) {
                Text('æš‚æ— å·²å­¦ä¹ ä¿¡å·ï¼Œè¿›å…¥å›´æ åŒºåŸŸåä¼šè‡ªåŠ¨å­¦ä¹ ')
                  .fontSize(13)
                  .fontColor('#999999')
                  .width('100%')
                  .textAlign(TextAlign.Center)
                  .padding(16)
              } else {
                ForEach(this.learnedSignals, (sig: LearnedSignalsSummary) => {
                  Column() {
                    Row() {
                      Column({ space: 2 }) {
                        Text(sig.geofenceName)
                          .fontSize(14)
                          .fontWeight(FontWeight.Medium)
                          .fontColor('#1A1A1A')
                        if (sig.wifiSsids.length > 0) {
                          Text('WiFi: ' + sig.wifiSsids.join(', '))
                            .fontSize(12)
                            .fontColor('#007AFF')
                        }
                        if (sig.btDevices.length > 0) {
                          Text('BT: ' + sig.btDevices.join(', '))
                            .fontSize(12)
                            .fontColor('#5856D6')
                        }
                        Text('è§‚æµ‹ ' + sig.totalObservations.toString() + ' æ¬¡')
                          .fontSize(11)
                          .fontColor('#999999')
                      }
                      .layoutWeight(1)
                      .alignItems(HorizontalAlign.Start)

                      Text('æ¸…é™¤')
                        .fontSize(13)
                        .fontColor('#FF3B30')
                        .padding(4)
                        .onClick(() => { this.clearSignalsForGeofence(sig.geofenceId); })
                    }
                    .width('100%')
                    .padding({ top: 8, bottom: 8 })
                    Divider().color('#F0F0F0')
                  }
                }, (sig: LearnedSignalsSummary) => sig.geofenceId)
              }
            }
            .width('100%')
            .padding(16)
            .backgroundColor(Color.White)
            .borderRadius(12)

            // ===== åé¦ˆç»Ÿè®¡ =====
            Column() {
              Row() {
                Text('åé¦ˆç»Ÿè®¡')
                  .fontSize(16)
                  .fontWeight(FontWeight.Bold)
                  .fontColor('#1A1A1A')
                  .layoutWeight(1)
                Text('åˆ·æ–°')
                  .fontSize(14)
                  .fontColor('#007AFF')
                  .onClick(() => {
                    this.refreshFeedbackStats();
                    try { promptAction.showToast({ message: 'åé¦ˆç»Ÿè®¡å·²åˆ·æ–°', duration: 1500 }); } catch {}
                  })
              }
              .width('100%')
              .margin({ bottom: 12 })

              // æ•°å­—ç»Ÿè®¡è¡Œ
              Row() {
                Column() {
                  Text(this.fbTotal.toString())
                    .fontSize(22)
                    .fontWeight(FontWeight.Bold)
                    .fontColor('#1A1A1A')
                  Text('æ€»åé¦ˆ')
                    .fontSize(11)
                    .fontColor('#999999')
                    .margin({ top: 2 })
                }
                .layoutWeight(1)
                .alignItems(HorizontalAlign.Center)

                Column() {
                  Text(this.fbRatioText)
                    .fontSize(22)
                    .fontWeight(FontWeight.Bold)
                    .fontColor('#4CAF50')
                  Text('å¥½è¯„ç‡')
                    .fontSize(11)
                    .fontColor('#999999')
                    .margin({ top: 2 })
                }
                .layoutWeight(1)
                .alignItems(HorizontalAlign.Center)

                Column() {
                  Text(this.fbPositive.toString() + ' / ' + this.fbNegative.toString())
                    .fontSize(16)
                    .fontWeight(FontWeight.Medium)
                    .fontColor('#1A1A1A')
                  Text('\uD83D\uDC4D / \uD83D\uDC4E')
                    .fontSize(11)
                    .fontColor('#999999')
                    .margin({ top: 2 })
                }
                .layoutWeight(1)
                .alignItems(HorizontalAlign.Center)
              }
              .width('100%')
              .padding({ top: 4, bottom: 8 })

              // Top è§„åˆ™
              if (this.fbTopRuleNames.length > 0) {
                Divider().color('#F0F0F0').margin({ top: 8, bottom: 8 })
                Text('æœ€æœ‰æ•ˆè§„åˆ™ Top ' + this.fbTopRuleNames.length.toString())
                  .fontSize(13)
                  .fontWeight(FontWeight.Medium)
                  .fontColor('#666666')
                  .width('100%')
                  .margin({ bottom: 6 })
                ForEach(this.fbTopRuleNames, (name: string, idx: number) => {
                  Row() {
                    Text((idx + 1).toString() + '.')
                      .fontSize(13)
                      .fontColor('#007AFF')
                      .fontWeight(FontWeight.Bold)
                      .width(20)
                    Text(name)
                      .fontSize(13)
                      .fontColor('#1A1A1A')
                      .layoutWeight(1)
                      .maxLines(1)
                      .textOverflow({ overflow: TextOverflow.Ellipsis })
                    Text(idx < this.fbTopRuleScores.length ? this.fbTopRuleScores[idx] : '')
                      .fontSize(12)
                      .fontColor('#999999')
                  }
                  .width('100%')
                  .padding({ top: 3, bottom: 3 })
                }, (name: string, idx: number) => name + '_' + idx.toString())
              }
            }
            .width('100%')
            .padding(16)
            .backgroundColor(Color.White)
            .borderRadius(12)

            // ===== MAB =====
            Column() {
              Row() {
                Text('MAB å­¦ä¹ ç»Ÿè®¡')
                  .fontSize(16)
                  .fontWeight(FontWeight.Bold)
                  .fontColor('#1A1A1A')
                  .layoutWeight(1)
                Text('åˆ·æ–°')
                  .fontSize(14)
                  .fontColor('#007AFF')
                  .onClick(() => {
                    try { this.mabStats = ContextEngineService.getInstance().getStats(); } catch (e) {}
                  })
              }
              .width('100%')
              .margin({ bottom: 8 })
              Text(this.mabStats.length > 2 ? this.mabStats : 'æš‚æ— æ•°æ®')
                .fontSize(12)
                .fontColor('#999999')
                .width('100%')
            }
            .width('100%')
            .padding(16)
            .backgroundColor(Color.White)
            .borderRadius(12)

            // ===== ä½ç½®è‡ªåŠ¨å‘ç° =====
            Column() {
              Row() {
                Text('ğŸ“ ä½ç½®è‡ªåŠ¨å‘ç°')
                  .fontSize(16)
                  .fontWeight(FontWeight.Bold)
                  .fontColor('#1A1A1A')
                  .layoutWeight(1)
                Text('ç«‹å³å‘ç°')
                  .fontSize(14)
                  .fontColor('#007AFF')
                  .onClick(() => { this.triggerDiscovery(); })
              }
              .width('100%')
              .margin({ bottom: 8 })

              Text(this.discoveryStats.length > 0 ? this.discoveryStats : 'æœªå¯åŠ¨')
                .fontSize(12)
                .fontColor('#999999')
                .width('100%')
                .margin({ bottom: 8 })

              if (this.suggestions.length === 0) {
                Text('æš‚æ— å‘ç°ï¼ŒGPS å†å²ç§¯ç´¯åä¼šè‡ªåŠ¨å‘ç°å¸¸å»åœ°ç‚¹')
                  .fontSize(13)
                  .fontColor('#999999')
                  .width('100%')
                  .textAlign(TextAlign.Center)
                  .padding(16)
              } else {
                ForEach(this.suggestions, (s: GeofenceSuggestion) => {
                  GeofenceSuggestionCard({
                    suggestionId: s.id,
                    name: s.name,
                    category: s.category,
                    reason: s.reason,
                    confidence: s.confidence,
                    latitude: s.latitude,
                    longitude: s.longitude,
                    radiusMeters: s.radiusMeters,
                    onAccept: (id: string, name: string, category: string) => {
                      this.handleAcceptSuggestion(id, name, category);
                    },
                    onIgnore: (id: string) => {
                      this.handleIgnoreSuggestion(id);
                    },
                    onDefer: (id: string) => {
                      this.handleDeferSuggestion(id);
                    },
                  })
                    .margin({ bottom: 8 })
                }, (s: GeofenceSuggestion) => s.id)
              }
            }
            .width('100%')
            .padding(16)
            .backgroundColor(Color.White)
            .borderRadius(12)
          }
          .padding({ left: 16, right: 16, top: 12, bottom: 40 })
        }
        .layoutWeight(1)
        .backgroundColor('#F2F2F7')
      }
      .width('100%')
      .height('100%')

      // ===== æ·»åŠ å›´æ å¼¹çª— =====
      if (this.showAddDialog) {
        Column() {
          Column({ space: 12 }) {
            Text('æ·»åŠ åœ°ç†å›´æ ')
              .fontSize(18)
              .fontWeight(FontWeight.Bold)
              .fontColor('#1A1A1A')

            TextInput({ placeholder: 'åç§°ï¼ˆå¦‚ï¼šå®¶ã€å…¬å¸ï¼‰' })
              .onChange((val: string) => { this.newName = val; })
              .width('100%')
              .height(44)

            Row({ space: 8 }) {
              TextInput({ placeholder: 'çº¬åº¦' })
                .onChange((val: string) => { this.newLat = val; })
                .layoutWeight(1)
                .height(44)
              TextInput({ placeholder: 'ç»åº¦' })
                .onChange((val: string) => { this.newLon = val; })
                .layoutWeight(1)
                .height(44)
            }
            .width('100%')

            TextInput({ placeholder: 'åŠå¾„ï¼ˆç±³ï¼‰ï¼Œé»˜è®¤100' })
              .onChange((val: string) => { this.newRadius = val; })
              .width('100%')
              .height(44)

            Text('ç±»åˆ«')
              .fontSize(14)
              .fontColor('#666666')

            Flex({ wrap: FlexWrap.Wrap }) {
              ForEach(this.catLabels, (label: string) => {
                Text(label)
                  .fontSize(13)
                  .fontColor(this.selectedCat === this.catLabels.indexOf(label) ? Color.White : '#1A1A1A')
                  .backgroundColor(this.selectedCat === this.catLabels.indexOf(label) ? '#007AFF' : '#F0F0F0')
                  .padding({ left: 12, right: 12, top: 6, bottom: 6 })
                  .borderRadius(16)
                  .margin(4)
                  .onClick(() => { this.selectedCat = this.catLabels.indexOf(label); })
              }, (label: string) => label)
            }
            .width('100%')

            Row({ space: 12 }) {
              Button('å–æ¶ˆ')
                .fontSize(14)
                .backgroundColor('#F0F0F0')
                .fontColor('#1A1A1A')
                .layoutWeight(1)
                .onClick(() => { this.showAddDialog = false; })
              Button('æ·»åŠ ')
                .fontSize(14)
                .backgroundColor('#007AFF')
                .fontColor(Color.White)
                .layoutWeight(1)
                .onClick(() => { this.doAddGeofence(); })
            }
            .width('100%')
            .margin({ top: 8 })
          }
          .width('85%')
          .padding(20)
          .backgroundColor(Color.White)
          .borderRadius(16)
          .shadow({ radius: 20, color: '#40000000' })
          .onClick(() => {})
        }
        .width('100%')
        .height('100%')
        .backgroundColor('#80000000')
        .justifyContent(FlexAlign.Center)
        .onClick(() => { this.showAddDialog = false; })
      }
    }
    .width('100%')
    .height('100%')
  }

  private doAddGeofence(): void {
    this.log.info('CtxSettings', 'Add: ' + this.newName + ' ' + this.newLat + ',' + this.newLon);
    if (this.newName.length === 0 || this.newLat.length === 0 || this.newLon.length === 0) return;
    let lat = parseFloat(this.newLat);
    let lon = parseFloat(this.newLon);
    let radius = this.newRadius.length > 0 ? parseFloat(this.newRadius) : 100;
    if (isNaN(lat) || isNaN(lon) || isNaN(radius)) return;
    try {
      let cas = ContextAwarenessService.getInstance();
      let gf: Geofence = {
        id: 'user_' + Date.now().toString(),
        name: this.newName,
        latitude: lat,
        longitude: lon,
        radiusMeters: radius,
        category: this.catIds[this.selectedCat] as GeofenceCategory,
      };
      cas.addGeofence(gf);
    } catch (err) {
      this.log.error('CtxSettings', 'Add error: ' + (err as Error).message);
    }
    this.showAddDialog = false;
    this.newName = '';
    this.newLat = '';
    this.newLon = '';
    this.newRadius = '100';
    this.selectedCat = 6;
    this.refresh();
  }

  private triggerDiscovery(): void {
    try {
      let cas = ContextAwarenessService.getInstance();
      let discovery = LocationDiscoveryService.getInstance();
      let stats = cas.getLocationDiscoveryStats();
      
      if (stats.historyCount < 10) {
        promptAction.showToast({
          message: I18n.t('context.discovery.notEnoughData'),
          duration: 2000
        });
        return;
      }
      
      promptAction.showToast({
        message: I18n.t('context.discovery.running'),
        duration: 1500
      });
      
      discovery.runDiscovery().then((suggestions: GeofenceSuggestion[]) => {
        this.suggestions = cas.getFilteredSuggestions();
        let newStats = cas.getLocationDiscoveryStats();
        this.discoveryStats = `å†å²ç‚¹: ${newStats.historyCount} | èšç±»: ${newStats.clusterCount} | ä¸Šæ¬¡å‘ç°: ${newStats.lastDiscovery}`;
        
        if (this.suggestions.length > 0) {
          promptAction.showToast({
            message: I18n.t('context.discovery.found').replace('{0}', this.suggestions.length.toString()),
            duration: 2000
          });
        } else {
          promptAction.showToast({
            message: I18n.t('context.discovery.noResult'),
            duration: 2000
          });
        }
      });
    } catch (err) {
      this.log.error('CtxSettings', 'Discovery error: ' + (err as Error).message);
    }
  }

  private handleAcceptSuggestion(clusterId: string, name: string, category: string): void {
    try {
      let cas = ContextAwarenessService.getInstance();
      let raw = this.locationDiscovery().getSuggestions();
      let match: GeofenceSuggestion | undefined = undefined;
      for (let i = 0; i < raw.length; i++) {
        if (raw[i].id === clusterId) {
          match = raw[i];
          break;
        }
      }
      if (match) {
        cas.acceptSuggestion(match, name, category);
      }
      this.refresh();
    } catch (err) {
      this.log.error('CtxSettings', 'Accept suggestion error: ' + (err as Error).message);
    }
  }

  private handleIgnoreSuggestion(clusterId: string): void {
    try {
      ContextAwarenessService.getInstance().ignoreSuggestion(clusterId);
      this.refresh();
    } catch (err) {
      this.log.error('CtxSettings', 'Ignore suggestion error: ' + (err as Error).message);
    }
  }

  private handleDeferSuggestion(clusterId: string): void {
    try {
      ContextAwarenessService.getInstance().deferSuggestion(clusterId);
      this.refresh();
    } catch (err) {
      this.log.error('CtxSettings', 'Defer suggestion error: ' + (err as Error).message);
    }
  }

  private locationDiscovery(): LocationDiscoveryService {
    return LocationDiscoveryService.getInstance();
  }

  private refreshTrayStatus(): void {
    try {
      let cas = ContextAwarenessService.getInstance();
      let statuses: TrayStatus[] = cas.getTrayStatus();

      let pK: string[] = [], pL: string[] = [], pV: string[] = [], pA: string[] = [], pI: string[] = [], pQ: string[] = [];
      let dK: string[] = [], dL: string[] = [], dV: string[] = [], dA: string[] = [], dI: string[] = [], dQ: string[] = [];

      for (let i = 0; i < statuses.length; i++) {
        let s: TrayStatus = statuses[i];
        let label = ContextSettingsPage.KEY_LABELS[s.key] ?? s.key;
        let val = s.value.length > 20 ? s.value.substring(0, 20) + '...' : s.value;
        let age = this.formatAge(s.ageMs);
        let ind = s.fresh ? '\u{1F7E2}' : (s.effectiveQuality > 0 ? '\u{1F7E1}' : '\u{1F534}');
        let qual = (s.effectiveQuality * 100).toFixed(0) + '%';

        if (s.source === 'digital') {
          dK.push(s.key); dL.push(label); dV.push(val); dA.push(age); dI.push(ind); dQ.push(qual);
        } else {
          pK.push(s.key); pL.push(label); pV.push(val); pA.push(age); pI.push(ind); pQ.push(qual);
        }
      }
      this.physKeys = pK; this.physLabels = pL; this.physValues = pV;
      this.physAges = pA; this.physIndicators = pI; this.physQualities = pQ;
      this.digiKeys = dK; this.digiLabels = dL; this.digiValues = dV;
      this.digiAges = dA; this.digiIndicators = dI; this.digiQualities = dQ;

      // æ›´æ–°é¡¶éƒ¨çŠ¶æ€æ¦‚è§ˆ
      this.updateStatusHeader(statuses);
    } catch (err) {
      this.physKeys = [];
      this.digiKeys = [];
    }
  }

  private formatAge(ms: number): string {
    if (ms < 1000) return ms.toString() + 'ms';
    if (ms < 60000) return (ms / 1000).toFixed(0) + 's';
    if (ms < 3600000) return (ms / 60000).toFixed(1) + 'm';
    return (ms / 3600000).toFixed(1) + 'h';
  }

  private updateStatusHeader(statuses: TrayStatus[]): void {
    let trayMap: Record<string, string> = {};
    for (let i = 0; i < statuses.length; i++) {
      trayMap[statuses[i].key] = statuses[i].value;
    }
    // æ—¶é—´
    let now = new Date();
    let h = now.getHours().toString().padStart(2, '0');
    let m = now.getMinutes().toString().padStart(2, '0');
    let tod = trayMap['timeOfDay'] ?? '';
    let todCn: Record<string, string> = { 'morning': 'ä¸Šåˆ', 'afternoon': 'ä¸‹åˆ', 'evening': 'å‚æ™š', 'night': 'æ™šä¸Š' };
    this.statusTime = h + ':' + m + ' ' + (todCn[tod] ?? tod);

    // è¿åŠ¨çŠ¶æ€
    let motion = trayMap['motionState'] ?? '';
    let motionCn: Record<string, string> = {
      'stationary': 'é™æ­¢', 'walking': 'æ­¥è¡Œ', 'running': 'è·‘æ­¥',
      'cycling': 'éª‘è¡Œ', 'driving': 'é©¾è½¦', 'transit': 'äº¤é€š',
      'pickup': 'æ‹¿èµ·æ‰‹æœº', 'putdown': 'æ”¾ä¸‹æ‰‹æœº', 'unknown': 'æœªçŸ¥'
    };
    this.statusMotion = motionCn[motion] ?? motion;

    // ç”µé‡
    let bat = trayMap['batteryLevel'] ?? '';
    let charging = trayMap['isCharging'] === 'true' ? ' \u26A1' : '';
    this.statusBattery = bat.length > 0 ? bat + '%' + charging : '';

    // ä½ç½®ï¼šæ ¹æ®å›´æ  ID æŸ¥æ‰¾å®é™…å›´æ ï¼Œæ˜¾ç¤ºåˆ†ç±»æ ‡ç­¾ + åç§°
    let geofenceId = trayMap['geofence'] ?? '';
    if (geofenceId.length > 0) {
      try {
        let gfs = ContextAwarenessService.getInstance().getAllGeofences();
        let matched = false;
        for (let i = 0; i < gfs.length; i++) {
          if (gfs[i].id === geofenceId) {
            let catLabel = I18n.t('place.category.' + gfs[i].category);
            this.statusLocation = this.getCatIcon(gfs[i].category) + ' ' + catLabel + ' ' + gfs[i].name;
            matched = true;
            break;
          }
        }
        if (!matched) {
          this.statusLocation = geofenceId;
        }
      } catch (_e) {
        this.statusLocation = geofenceId;
      }
    } else {
      this.statusLocation = '';
    }

    // WiFi
    let wifi = trayMap['wifiSsid'] ?? '';
    this.statusWifi = wifi.length > 0 ? 'WiFi: ' + wifi : '';
  }

  private deleteGeofence(id: string): void {
    try {
      ContextAwarenessService.getInstance().removeGeofence(id);
    } catch (err) {
      this.log.error('CtxSettings', 'Del error: ' + (err as Error).message);
    }
    this.refresh();
  }

  private clearSignalsForGeofence(geofenceId: string): void {
    try {
      ContextAwarenessService.getInstance().clearLearnedSignals(geofenceId).then(() => {
        this.refresh();
      });
    } catch (err) {
      this.log.error('CtxSettings', 'Clear signals error: ' + (err as Error).message);
    }
  }

  private clearAllSignals(): void {
    try {
      ContextAwarenessService.getInstance().clearAllLearnedSignals().then(() => {
        this.refresh();
      });
    } catch (err) {
      this.log.error('CtxSettings', 'Clear all signals error: ' + (err as Error).message);
    }
  }
}
